#!/usr/bin/env python3
"""Generate single-file HTML report with all provenance evidence.

Creates evidence/report.html with sections for:
- CI Summary
- Dataset Contracts
- Calibration Metrics (with reliability diagram)
- Epistemic Metrics
- Double-Build Verification

Usage:
    python scripts/report_html.py
    python scripts/report_html.py --output evidence/report.html
"""

import argparse
import json
import pathlib
import sys
from datetime import datetime, timezone
from typing import Dict, Any, List

from _config import get_config


HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Provenance Report - {git_sha}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 20px; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }}
        header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 40px; }}
        header h1 {{ font-size: 2.5em; margin-bottom: 10px; }}
        header .subtitle {{ opacity: 0.9; font-size: 1.1em; }}
        .content {{ padding: 40px; }}
        section {{ margin-bottom: 40px; }}
        h2 {{ color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-bottom: 20px; }}
        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; background: white; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background: #f8f9fa; font-weight: 600; }}
        .metric-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0; }}
        .metric-card {{ background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #667eea; }}
        .metric-card h3 {{ font-size: 0.9em; color: #666; margin-bottom: 8px; }}
        .metric-card .value {{ font-size: 2em; font-weight: bold; color: #333; }}
        .metric-card .status {{ font-size: 0.9em; margin-top: 8px; }}
        .pass {{ color: #28a745; }}
        .fail {{ color: #dc3545; }}
        .warn {{ color: #ffc107; }}
        .code-block {{ background: #f8f9fa; padding: 15px; border-radius: 4px; font-family: 'Courier New', monospace; overflow-x: auto; }}
        footer {{ background: #f8f9fa; padding: 20px; text-align: center; color: #666; font-size: 0.9em; }}
        .chart {{ margin: 20px 0; }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üî¨ Provenance Report</h1>
            <div class="subtitle">
                Git SHA: <code>{git_sha}</code> | Branch: <code>{git_branch}</code> | Generated: {timestamp}
            </div>
        </header>
        
        <div class="content">
            {sections}
        </div>
        
        <footer>
            <p>Generated by provenance pipeline | <a href="https://github.com/GOATnote-Inc/periodicdent42">periodicdent42</a></p>
            <p>¬© 2025 GOATnote Autonomous Research Lab Initiative</p>
        </footer>
    </div>
</body>
</html>
"""


def read_json_safe(filepath: pathlib.Path) -> Dict[str, Any]:
    """Read JSON file safely, return empty dict on error.
    
    Args:
        filepath: Path to JSON file
    
    Returns:
        Dict from JSON or empty dict
    """
    try:
        if filepath.exists():
            with filepath.open() as f:
                return json.load(f)
    except Exception as e:
        print(f"‚ö†Ô∏è  Error reading {filepath}: {e}", file=sys.stderr)
    return {}


def read_jsonl_last(filepath: pathlib.Path) -> Dict[str, Any]:
    """Read last entry from JSONL file.
    
    Args:
        filepath: Path to JSONL file
    
    Returns:
        Last entry dict or empty dict
    """
    try:
        if filepath.exists():
            with filepath.open() as f:
                lines = f.readlines()
                if lines:
                    return json.loads(lines[-1])
    except Exception as e:
        print(f"‚ö†Ô∏è  Error reading {filepath}: {e}", file=sys.stderr)
    return {}


def generate_ci_summary_section(config: Dict[str, Any], coverage_data: Dict[str, Any]) -> str:
    """Generate CI summary section HTML.
    
    Args:
        config: Config dict from _config
        coverage_data: Coverage data from coverage.json
    
    Returns:
        HTML string
    """
    coverage_pct = coverage_data.get("totals", {}).get("percent_covered", 0.0)
    coverage_status = "pass" if coverage_pct >= config["COVERAGE_MIN"] else "fail"
    
    return f"""
        <section id="ci-summary">
            <h2>üìä CI Summary</h2>
            <div class="metric-grid">
                <div class="metric-card">
                    <h3>Coverage</h3>
                    <div class="value">{coverage_pct:.1f}%</div>
                    <div class="status {coverage_status}">
                        Target: {config["COVERAGE_MIN"]:.1f}%
                    </div>
                </div>
                <div class="metric-card">
                    <h3>Git SHA</h3>
                    <div class="value" style="font-size: 1.2em;">{config["GIT_SHA"][:8]}</div>
                    <div class="status">Branch: {config["GIT_BRANCH"]}</div>
                </div>
                <div class="metric-card">
                    <h3>CI Run ID</h3>
                    <div class="value" style="font-size: 1.2em;">{config["CI_RUN_ID"][:12]}</div>
                    <div class="status">Continuous Integration</div>
                </div>
            </div>
        </section>
    """


def generate_dataset_contracts_section(base_dir: pathlib.Path) -> str:
    """Generate dataset contracts section HTML.
    
    Args:
        base_dir: Repository root directory
    
    Returns:
        HTML string
    """
    contracts_file = base_dir / "data_contracts.yaml"
    
    if not contracts_file.exists():
        return """
        <section id="dataset-contracts">
            <h2>üì¶ Dataset Contracts</h2>
            <p class="warn">‚ö†Ô∏è data_contracts.yaml not found</p>
        </section>
        """
    
    # Parse YAML manually (avoid adding pyyaml dependency)
    datasets_html = ""
    try:
        with contracts_file.open() as f:
            lines = f.readlines()
        
        # Simple YAML parsing for dataset checksums
        datasets_html = "<table><thead><tr><th>Dataset</th><th>Path</th><th>Checksum (SHA256)</th><th>Status</th></tr></thead><tbody>"
        
        current_dataset = None
        current_path = None
        current_checksum = None
        
        for line in lines:
            line = line.rstrip()
            if line.startswith("  ") and not line.startswith("    ") and ":" in line and not line.strip().startswith("#"):
                # Dataset name
                if current_dataset and current_path:
                    status = "‚úÖ Verified" if current_checksum and "placeholder" not in current_checksum else "‚ö†Ô∏è Not initialized"
                    datasets_html += f"<tr><td><strong>{current_dataset}</strong></td><td><code>{current_path}</code></td><td><code>{current_checksum[:16]}...</code></td><td>{status}</td></tr>"
                
                current_dataset = line.split(":")[0].strip()
                current_path = None
                current_checksum = None
            elif "path:" in line:
                current_path = line.split("path:")[1].strip().strip('"')
            elif "checksum:" in line:
                current_checksum = line.split("checksum:")[1].strip()
                if current_checksum == "null":
                    current_checksum = "not_initialized"
        
        # Last dataset
        if current_dataset and current_path:
            status = "‚úÖ Verified" if current_checksum and "placeholder" not in current_checksum else "‚ö†Ô∏è Not initialized"
            datasets_html += f"<tr><td><strong>{current_dataset}</strong></td><td><code>{current_path}</code></td><td><code>{current_checksum[:16]}...</code></td><td>{status}</td></tr>"
        
        datasets_html += "</tbody></table>"
    
    except Exception as e:
        datasets_html = f'<p class="fail">Error parsing data_contracts.yaml: {e}</p>'
    
    return f"""
        <section id="dataset-contracts">
            <h2>üì¶ Dataset Contracts</h2>
            {datasets_html}
        </section>
    """


def generate_calibration_section(ledger_data: Dict[str, Any], config: Dict[str, Any]) -> str:
    """Generate calibration metrics section HTML.
    
    Args:
        ledger_data: Latest ledger entry dict
        config: Config dict
    
    Returns:
        HTML string
    """
    calibration = ledger_data.get("calibration", {})
    ece = calibration.get("ece", 0.0)
    brier = calibration.get("brier_score", 0.0)
    mce = calibration.get("mce", 0.0)
    
    ece_status = "pass" if ece <= config["ECE_MAX"] else "fail"
    brier_status = "pass" if brier <= config["BRIER_MAX"] else "fail"
    mce_status = "pass" if mce <= config["MCE_MAX"] else "fail"
    
    return f"""
        <section id="calibration">
            <h2>üéØ Model Calibration</h2>
            <div class="metric-grid">
                <div class="metric-card">
                    <h3>Expected Calibration Error (ECE)</h3>
                    <div class="value">{ece:.4f}</div>
                    <div class="status {ece_status}">
                        Threshold: {config["ECE_MAX"]:.4f}
                    </div>
                </div>
                <div class="metric-card">
                    <h3>Brier Score</h3>
                    <div class="value">{brier:.4f}</div>
                    <div class="status {brier_status}">
                        Threshold: {config["BRIER_MAX"]:.4f}
                    </div>
                </div>
                <div class="metric-card">
                    <h3>Maximum Calibration Error (MCE)</h3>
                    <div class="value">{mce:.4f}</div>
                    <div class="status {mce_status}">
                        Threshold: {config["MCE_MAX"]:.4f}
                    </div>
                </div>
            </div>
            <p style="margin-top: 20px; color: #666; font-size: 0.95em;">
                <strong>Calibration</strong> measures how well predicted probabilities match empirical frequencies.
                Lower ECE/Brier/MCE indicates better calibration (more reliable predictions).
            </p>
        </section>
    """


def generate_epistemic_section(ledger_data: Dict[str, Any]) -> str:
    """Generate epistemic metrics section HTML.
    
    Args:
        ledger_data: Latest ledger entry dict
    
    Returns:
        HTML string
    """
    uncertainty = ledger_data.get("uncertainty", {})
    selector_metrics = ledger_data.get("selector_metrics", {})
    
    entropy_before = uncertainty.get("entropy_before", 0.0)
    entropy_after = uncertainty.get("entropy_after", 0.0)
    avg_eig = selector_metrics.get("avg_eig_bits", 0.0)
    
    return f"""
        <section id="epistemic">
            <h2>üß† Epistemic Metrics</h2>
            <div class="metric-grid">
                <div class="metric-card">
                    <h3>Entropy Before</h3>
                    <div class="value">{entropy_before:.4f}</div>
                    <div class="status">bits</div>
                </div>
                <div class="metric-card">
                    <h3>Entropy After</h3>
                    <div class="value">{entropy_after:.4f}</div>
                    <div class="status">bits</div>
                </div>
                <div class="metric-card">
                    <h3>Avg Expected Info Gain</h3>
                    <div class="value">{avg_eig:.4f}</div>
                    <div class="status">bits per test</div>
                </div>
            </div>
            <p style="margin-top: 20px; color: #666; font-size: 0.95em;">
                <strong>Epistemic metrics</strong> quantify information gain from test selection.
                Higher EIG indicates tests that provide more useful signal about system behavior.
            </p>
        </section>
    """


def generate_build_verification_section(base_dir: pathlib.Path) -> str:
    """Generate double-build verification section HTML.
    
    Args:
        base_dir: Repository root directory
    
    Returns:
        HTML string
    """
    # Check for build hash files
    first_hash_file = base_dir / "evidence" / "builds" / "first.hash"
    second_hash_file = base_dir / "evidence" / "builds" / "second.hash"
    
    if first_hash_file.exists() and second_hash_file.exists():
        first_hash = first_hash_file.read_text().strip()
        second_hash = second_hash_file.read_text().strip()
        
        identical = first_hash == second_hash
        status_class = "pass" if identical else "fail"
        status_text = "‚úÖ Bit-Identical" if identical else "‚ùå Diverged"
        
        return f"""
        <section id="build-verification">
            <h2>üî® Double-Build Verification</h2>
            <div class="metric-card">
                <h3>Reproducibility Status</h3>
                <div class="value {status_class}" style="font-size: 1.5em;">{status_text}</div>
            </div>
            <table style="margin-top: 20px;">
                <thead><tr><th>Build</th><th>Hash</th></tr></thead>
                <tbody>
                    <tr><td>First</td><td><code>{first_hash[:64]}</code></td></tr>
                    <tr><td>Second</td><td><code>{second_hash[:64]}</code></td></tr>
                </tbody>
            </table>
        </section>
        """
    else:
        return """
        <section id="build-verification">
            <h2>üî® Double-Build Verification</h2>
            <p class="warn">‚ö†Ô∏è Build hashes not found. Run <code>make repro</code> first.</p>
        </section>
        """


def main() -> int:
    """Generate HTML report.
    
    Returns:
        0 on success, 1 on error
    """
    parser = argparse.ArgumentParser(description="Generate HTML provenance report")
    parser.add_argument("--output", type=pathlib.Path, default="evidence/report.html",
                        help="Output HTML path (default: evidence/report.html)")
    parser.add_argument("--base-dir", type=pathlib.Path, default=pathlib.Path.cwd(),
                        help="Repository root directory")
    args = parser.parse_args()
    
    config = get_config()
    base_dir = args.base_dir.resolve()
    
    print("=" * 80)
    print("HTML REPORT GENERATOR")
    print("=" * 80)
    print()
    
    # Load data
    print("üìÇ Loading data...")
    coverage_data = read_json_safe(base_dir / "coverage.json")
    
    # Find latest ledger entry
    ledger_dir = base_dir / "experiments" / "ledger"
    ledger_data = {}
    if ledger_dir.exists():
        ledger_files = sorted(ledger_dir.glob("*.jsonl"))
        if ledger_files:
            ledger_data = read_jsonl_last(ledger_files[-1])
    
    print("   Loaded coverage, ledger, contracts")
    print()
    
    # Generate sections
    print("üìù Generating sections...")
    sections = []
    sections.append(generate_ci_summary_section(config, coverage_data))
    sections.append(generate_dataset_contracts_section(base_dir))
    sections.append(generate_calibration_section(ledger_data, config))
    sections.append(generate_epistemic_section(ledger_data))
    sections.append(generate_build_verification_section(base_dir))
    print()
    
    # Generate HTML
    html = HTML_TEMPLATE.format(
        git_sha=config["GIT_SHA"],
        git_branch=config["GIT_BRANCH"],
        timestamp=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC"),
        sections="\n".join(sections)
    )
    
    # Write file
    print(f"üíæ Writing report to: {args.output}")
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(html)
    print()
    
    print("‚úÖ Report generated successfully!")
    print()
    print(f"   Open in browser: open {args.output}")
    print()
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
